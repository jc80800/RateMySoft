// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
WHERE deleted_at IS NULL
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByCompany = `-- name: CountProductsByCompany :one
SELECT COUNT(*) FROM products
WHERE company_id = $1 AND deleted_at IS NULL
`

func (q *Queries) CountProductsByCompany(ctx context.Context, companyID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByCompany, companyID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    id, company_id, name, slug, category, short_tagline, description,
    homepage_url, docs_url, avg_rating, total_reviews, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, company_id, name, slug, category, short_tagline, description, homepage_url, docs_url, avg_rating, total_reviews, created_at, updated_at, deleted_at
`

type CreateProductParams struct {
	ID           uuid.UUID          `json:"id"`
	CompanyID    uuid.UUID          `json:"company_id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Category     string             `json:"category"`
	ShortTagline *string            `json:"short_tagline"`
	Description  *string            `json:"description"`
	HomepageUrl  *string            `json:"homepage_url"`
	DocsUrl      *string            `json:"docs_url"`
	AvgRating    *float64           `json:"avg_rating"`
	TotalReviews int32              `json:"total_reviews"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.CompanyID,
		arg.Name,
		arg.Slug,
		arg.Category,
		arg.ShortTagline,
		arg.Description,
		arg.HomepageUrl,
		arg.DocsUrl,
		arg.AvgRating,
		arg.TotalReviews,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Slug,
		&i.Category,
		&i.ShortTagline,
		&i.Description,
		&i.HomepageUrl,
		&i.DocsUrl,
		&i.AvgRating,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, company_id, name, slug, category, short_tagline, description, homepage_url, docs_url, avg_rating, total_reviews, created_at, updated_at, deleted_at FROM products
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetProduct(ctx context.Context, id uuid.UUID) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Slug,
		&i.Category,
		&i.ShortTagline,
		&i.Description,
		&i.HomepageUrl,
		&i.DocsUrl,
		&i.AvgRating,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT p.id, p.company_id, p.name, p.slug, p.category, p.short_tagline, p.description, p.homepage_url, p.docs_url, p.avg_rating, p.total_reviews, p.created_at, p.updated_at, p.deleted_at, c.name as company_name, c.slug as company_slug
FROM products p
JOIN companies c ON p.company_id = c.id
WHERE p.slug = $1 AND p.deleted_at IS NULL AND c.deleted_at IS NULL
`

type GetProductBySlugRow struct {
	ID           uuid.UUID          `json:"id"`
	CompanyID    uuid.UUID          `json:"company_id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Category     string             `json:"category"`
	ShortTagline *string            `json:"short_tagline"`
	Description  *string            `json:"description"`
	HomepageUrl  *string            `json:"homepage_url"`
	DocsUrl      *string            `json:"docs_url"`
	AvgRating    *float64           `json:"avg_rating"`
	TotalReviews int32              `json:"total_reviews"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	CompanyName  string             `json:"company_name"`
	CompanySlug  string             `json:"company_slug"`
}

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (GetProductBySlugRow, error) {
	row := q.db.QueryRow(ctx, getProductBySlug, slug)
	var i GetProductBySlugRow
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Slug,
		&i.Category,
		&i.ShortTagline,
		&i.Description,
		&i.HomepageUrl,
		&i.DocsUrl,
		&i.AvgRating,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CompanyName,
		&i.CompanySlug,
	)
	return i, err
}

const getProductsByCompany = `-- name: GetProductsByCompany :many
SELECT id, company_id, name, slug, category, short_tagline, description, homepage_url, docs_url, avg_rating, total_reviews, created_at, updated_at, deleted_at FROM products
WHERE company_id = $1 AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductsByCompanyParams struct {
	CompanyID uuid.UUID `json:"company_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
}

func (q *Queries) GetProductsByCompany(ctx context.Context, arg GetProductsByCompanyParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Slug,
			&i.Category,
			&i.ShortTagline,
			&i.Description,
			&i.HomepageUrl,
			&i.DocsUrl,
			&i.AvgRating,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hardDeleteProduct = `-- name: HardDeleteProduct :exec
DELETE FROM products
WHERE id = $1
`

func (q *Queries) HardDeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, hardDeleteProduct, id)
	return err
}

const listProducts = `-- name: ListProducts :many
SELECT p.id, p.company_id, p.name, p.slug, p.category, p.short_tagline, p.description, p.homepage_url, p.docs_url, p.avg_rating, p.total_reviews, p.created_at, p.updated_at, p.deleted_at, c.name as company_name, c.slug as company_slug
FROM products p
JOIN companies c ON p.company_id = c.id
WHERE p.deleted_at IS NULL AND c.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProductsRow struct {
	ID           uuid.UUID          `json:"id"`
	CompanyID    uuid.UUID          `json:"company_id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Category     string             `json:"category"`
	ShortTagline *string            `json:"short_tagline"`
	Description  *string            `json:"description"`
	HomepageUrl  *string            `json:"homepage_url"`
	DocsUrl      *string            `json:"docs_url"`
	AvgRating    *float64           `json:"avg_rating"`
	TotalReviews int32              `json:"total_reviews"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	CompanyName  string             `json:"company_name"`
	CompanySlug  string             `json:"company_slug"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Slug,
			&i.Category,
			&i.ShortTagline,
			&i.Description,
			&i.HomepageUrl,
			&i.DocsUrl,
			&i.AvgRating,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CompanyName,
			&i.CompanySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategory = `-- name: ListProductsByCategory :many
SELECT p.id, p.company_id, p.name, p.slug, p.category, p.short_tagline, p.description, p.homepage_url, p.docs_url, p.avg_rating, p.total_reviews, p.created_at, p.updated_at, p.deleted_at, c.name as company_name, c.slug as company_slug
FROM products p
JOIN companies c ON p.company_id = c.id
WHERE p.category = $1 AND p.deleted_at IS NULL AND c.deleted_at IS NULL
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsByCategoryParams struct {
	Category string `json:"category"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

type ListProductsByCategoryRow struct {
	ID           uuid.UUID          `json:"id"`
	CompanyID    uuid.UUID          `json:"company_id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Category     string             `json:"category"`
	ShortTagline *string            `json:"short_tagline"`
	Description  *string            `json:"description"`
	HomepageUrl  *string            `json:"homepage_url"`
	DocsUrl      *string            `json:"docs_url"`
	AvgRating    *float64           `json:"avg_rating"`
	TotalReviews int32              `json:"total_reviews"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	CompanyName  string             `json:"company_name"`
	CompanySlug  string             `json:"company_slug"`
}

func (q *Queries) ListProductsByCategory(ctx context.Context, arg ListProductsByCategoryParams) ([]ListProductsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listProductsByCategory, arg.Category, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsByCategoryRow
	for rows.Next() {
		var i ListProductsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Slug,
			&i.Category,
			&i.ShortTagline,
			&i.Description,
			&i.HomepageUrl,
			&i.DocsUrl,
			&i.AvgRating,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CompanyName,
			&i.CompanySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT p.id, p.company_id, p.name, p.slug, p.category, p.short_tagline, p.description, p.homepage_url, p.docs_url, p.avg_rating, p.total_reviews, p.created_at, p.updated_at, p.deleted_at, c.name as company_name, c.slug as company_slug
FROM products p
JOIN companies c ON p.company_id = c.id
WHERE p.deleted_at IS NULL AND c.deleted_at IS NULL
AND (p.name ILIKE $1 OR p.short_tagline ILIKE $1 OR c.name ILIKE $1)
ORDER BY p.name ASC
LIMIT $2 OFFSET $3
`

type SearchProductsParams struct {
	Name   string `json:"name"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type SearchProductsRow struct {
	ID           uuid.UUID          `json:"id"`
	CompanyID    uuid.UUID          `json:"company_id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Category     string             `json:"category"`
	ShortTagline *string            `json:"short_tagline"`
	Description  *string            `json:"description"`
	HomepageUrl  *string            `json:"homepage_url"`
	DocsUrl      *string            `json:"docs_url"`
	AvgRating    *float64           `json:"avg_rating"`
	TotalReviews int32              `json:"total_reviews"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	CompanyName  string             `json:"company_name"`
	CompanySlug  string             `json:"company_slug"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts, arg.Name, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsRow
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.CompanyID,
			&i.Name,
			&i.Slug,
			&i.Category,
			&i.ShortTagline,
			&i.Description,
			&i.HomepageUrl,
			&i.DocsUrl,
			&i.AvgRating,
			&i.TotalReviews,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CompanyName,
			&i.CompanySlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProduct = `-- name: SoftDeleteProduct :exec
UPDATE products
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteProduct, id)
	return err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET 
    name = $2,
    slug = $3,
    category = $4,
    short_tagline = $5,
    description = $6,
    homepage_url = $7,
    docs_url = $8,
    avg_rating = $9,
    total_reviews = $10,
    updated_at = $11
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, company_id, name, slug, category, short_tagline, description, homepage_url, docs_url, avg_rating, total_reviews, created_at, updated_at, deleted_at
`

type UpdateProductParams struct {
	ID           uuid.UUID          `json:"id"`
	Name         string             `json:"name"`
	Slug         string             `json:"slug"`
	Category     string             `json:"category"`
	ShortTagline *string            `json:"short_tagline"`
	Description  *string            `json:"description"`
	HomepageUrl  *string            `json:"homepage_url"`
	DocsUrl      *string            `json:"docs_url"`
	AvgRating    *float64           `json:"avg_rating"`
	TotalReviews int32              `json:"total_reviews"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Category,
		arg.ShortTagline,
		arg.Description,
		arg.HomepageUrl,
		arg.DocsUrl,
		arg.AvgRating,
		arg.TotalReviews,
		arg.UpdatedAt,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.CompanyID,
		&i.Name,
		&i.Slug,
		&i.Category,
		&i.ShortTagline,
		&i.Description,
		&i.HomepageUrl,
		&i.DocsUrl,
		&i.AvgRating,
		&i.TotalReviews,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateProductStats = `-- name: UpdateProductStats :exec
UPDATE products
SET 
    avg_rating = $2,
    total_reviews = $3,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateProductStatsParams struct {
	ID           uuid.UUID `json:"id"`
	AvgRating    *float64  `json:"avg_rating"`
	TotalReviews int32     `json:"total_reviews"`
}

func (q *Queries) UpdateProductStats(ctx context.Context, arg UpdateProductStatsParams) error {
	_, err := q.db.Exec(ctx, updateProductStats, arg.ID, arg.AvgRating, arg.TotalReviews)
	return err
}
